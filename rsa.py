import gmpy2, random
from gmpy2 import isqrt, c_div
import sys, hashlib
from sympy import *

#N = 402549892138698633694587658223
#e = 262826421987006987373196544223

N = 519985226017586718590291041206218018118745831730448737560757322438245574538954217143832717893391968207912146657803330291082892245198552398119578874443523145843518812647975793130001886666422249584493863380681491224573783282881963612458151356312589317136945656839546901945222113583295802069384498052107258240629338507681165223508346046665122966408628563080544014403828261348891171903770648972138597421688545847454518107412886697372507992952442806719491403065114730487865932134918649699413607695091494208363912306264988366372835548543156689542690132501881626684782403920158153820723777239526927905765881020090121081383600873757597789830398155134371420809649950928165106615614813930192903573031001465898645270955707456107543940047964970976698194901504725730939473921513448568016645198737517082633447033827986168910290529058743695974057141467930340746642896279305313993206403307285917659190941488950279137831125199724096505697754098147440604595758370542879516608947778240820129408939365123729275907696282091480474596659443854418721179835603811071753894057730574237744479649900338501767512700866580823776044829576882847091747712133875057764913725540803074466958109892665857517825606075603943954185638243846935626348603275183638909462034341
e = 343047047685392335416501405652908550348051885052425611890102781475602589107207785166741055013278747415189495030241628517100252058959171226602290167168210915420115253331382143942268152908027581304294500246194373735216887534648198849504255711244057566412243669876221139222764254363162892504256416938040188735524496897840652437837179642300478281919388052399466875303409738635599130707532468418090381800888168272573661041212643430248388214118692637179129366498908566730282120758068789215609992820205236378852064340910386456861747323298546374890269857559288170249036223718366191438792987198052325728441839030213579163739595702094237429927434049920193599136771892000077740734474192421824964823222988267194735210250974624843412844748757795399584079950099828565182491701832083040454825673207618684011144750535916604011028078153810617693387674828988825764709625779277317876045920215040230763311143036795287307101923897351721153910620196498945906725796630650432502303329270725060890754278520176356762735502058819926891666621010268923942298513760465926343139718387726906224713295910253461268331338123131424869472363660483684533918688812585724098755135187684814567502185990640086829899344105482774288885074282216802241847531207331437634345387059

def get_cf_expansion(n, d):
    e = []

    q = n // d
    r = n % d
    e.append(q)

    while r != 0:
        n, d = d, r
        q = n // d
        r = n % d
        e.append(q)

    return e

def get_convergents(e):
    n = [] # Nominators
    d = [] # Denominators

    for i in range(len(e)):
        if i == 0:
            ni = e[i]
            di = 1
        elif i == 1:
            ni = e[i]*e[i-1] + 1
            di = e[i]
        else: # i > 1
            ni = e[i]*n[i-1] + n[i-2]
            di = e[i]*d[i-1] + d[i-2]

        n.append(ni)
        d.append(di)
        yield (ni, di)

def sha1(n):
    h = hashlib.sha1()
    h.update(str(n).encode('utf-8'))
    return h.hexdigest()

urandom = random.SystemRandom()

def get_prime(size):
    while True:
        r = urandom.getrandbits(size)
        if gmpy2.is_prime(r): # Miller-rabin
            return r

def test_key(N, e, d):
    msg = (N - 123) >> 7
    c = pow(msg, e, N)
    return pow(c, d, N) ==  msg

def create_keypair(size):
    while True:
        p = get_prime(size // 2)
        q = get_prime(size // 2)
        if q < p < 2*q:
            break

    N = p * q
    phi_N = (p - 1) * (q - 1)

    # Recall that: d < (N^(0.25))/3
    max_d = c_div(isqrt(isqrt(N)), 3)
    max_d_bits = max_d.bit_length() - 1

    while True:
        d = urandom.getrandbits(max_d_bits)
        try:
            e = int(gmpy2.invert(d, phi_N))
        except ZeroDivisionError:
            continue
        if (e * d) % phi_N == 1:
            break
    assert test_key(N, e, d)

    return  N, e, d, p, q

cf_expansion = get_cf_expansion(e, N)
convergents = get_convergents(cf_expansion)

for pk, pd in convergents: # pk - possible k, pd - possible d
    if pk == 0:
        continue;

    possible_phi = (e*pd - 1)//pk

    p = Symbol('p', integer=True)
    roots = solve(p**2 + (possible_phi - N - 1)*p + N, p)

    if len(roots) == 2:
        pp, pq = roots # pp - possible p, pq - possible q
        if pp*pq == N:
            print('[+] Factored N! :) derived keypair components:')
            print('[+] ++ e:    ', e)
            print('[+] ++ d:    ', pd)
            print('[+] ++ N:    ', N)
            print('[+] ++ p:    ', pp)
            print('[+] ++ q:    ', pq)
            print('[+] ++ phiN: ', possible_phi)
            sys.exit(0)

print('[-] Wiener\'s Attack failed; Could not factor N')
